{
  "version": 3,
  "sources": ["../../.pnpm/preact@10.27.2/node_modules/preact/hooks/src/index.js", "../../.pnpm/@preact+signals-core@1.12.1/node_modules/@preact/signals-core/src/index.ts", "../../.pnpm/@preact+signals@1.3.2_preact@10.27.2/node_modules/@preact/signals/src/index.ts"],
  "sourcesContent": ["import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n", "import { options, Component, isValidElement } from \"preact\";\nimport { useRef, useMemo, useEffect } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction SignalValue(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst s = useMemo(() => {\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._updater!._callback = () => {\n\t\t\tconst end = this._updater!._start();\n\t\t\tconst value = s.value;\n\t\t\tend();\n\n\t\t\tif (isValidElement(value) || this.base?.nodeType !== 3) {\n\t\t\t\tthis._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tthis.setState({});\n\t\t\t} else {\n\t\t\t\t(this.base as Text).data = value;\n\t\t\t}\n\t\t};\n\n\t\treturn computed(() => {\n\t\t\tlet data = currentSignal.value;\n\t\t\tlet s = data.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\t}, []);\n\n\treturn s.value;\n}\nSignalValue.displayName = \"_st\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tsetCurrentUpdater();\n\n\tlet updater;\n\n\tlet component = vnode.__c;\n\tif (component) {\n\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\tupdater = component._updater;\n\t\tif (updater === undefined) {\n\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tcomponent.setState({});\n\t\t\t});\n\t\t}\n\t}\n\n\tcurrentComponent = component;\n\tsetCurrentUpdater(updater);\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(() => {\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3 || type === 9)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// let reason;\n\t// if (!hasSignals && !hasComputeds.has(this)) {\n\t// \treason = \"no signals or computeds\";\n\t// } else if (hasPendingUpdate.has(this)) {\n\t// \treason = \"has pending update\";\n\t// } else if (hasHookState.has(this)) {\n\t// \treason = \"has hook state\";\n\t// }\n\t// if (reason) {\n\t// \tif (!this) reason += \" (`this` bug)\";\n\t// \tconsole.log(\"not optimizing\", this?.constructor?.name, \": \", reason, {\n\t// \t\tdetails: {\n\t// \t\t\thasSignals,\n\t// \t\t\thasComputeds: hasComputeds.has(this),\n\t// \t\t\thasPendingUpdate: hasPendingUpdate.has(this),\n\t// \t\t\thasHookState: hasHookState.has(this),\n\t// \t\t\tdeps: Array.from(updater._deps),\n\t// \t\t\tupdater,\n\t// \t\t},\n\t// \t});\n\t// }\n\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\tif (this.__f || (typeof this.u == \"boolean\" && this.u === true)) {\n\t\tconst hasHooksState = this._updateFlags & HAS_HOOK_STATE;\n\t\t// if this component used no signals or computeds and no hooks state, update:\n\t\tif (!hasSignals && !hasHooksState && !(this._updateFlags & HAS_COMPUTEDS))\n\t\t\treturn true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & HAS_PENDING_UPDATE) return true;\n\t} else {\n\t\t// if this component used no signals or computeds, update:\n\t\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\t}\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), []);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\treturn useMemo(() => computed<T>(() => $compute.current()), []);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n"],
  "mappings": "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",
  "names": ["currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useEffect", "callback", "args", "state", "getHookState", "currentIndex", "options", "__s", "argsChanged", "__H", "__", "_pendingArgs", "currentComponent", "__h", "push", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "fn", "evalContext", "untracked", "prevContext", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_subscribe", "Signal", "value", "options", "this", "_value", "_targets", "_watched", "watched", "_unwatched", "unwatched", "name", "prototype", "brand", "_refresh", "_this", "targets", "_this$_watched", "call", "_unsubscribe", "_this2", "prev", "_this2$_unwatched", "subscribe", "_this3", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "undefined", "_fn", "_globalVersion", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "finish", "_start", "bind", "_dispose", "dispose", "currentComponent", "finishUpdate", "hook", "hookName", "hookFn", "options", "bind", "setCurrentUpdater", "updater", "_start", "SignalValue", "_ref", "_this", "this", "data", "currentSignal", "useSignal", "value", "s", "useMemo", "v", "__v", "__", "__c", "_updateFlags", "_updater", "_callback", "_this$base", "end", "isValidElement", "base", "nodeType", "setState", "computed", "displayName", "Object", "defineProperties", "Signal", "prototype", "constructor", "configurable", "undefined", "type", "props", "get", "__b", "old", "vnode", "signalProps", "i", "__np", "peek", "component", "update", "effect", "createUpdater", "error", "oldVNode", "dom", "__e", "renderedProps", "updaters", "_updaters", "prop", "_dispose", "signal", "createPropUpdater", "_update", "propSignal", "setAsProperty", "ownerSVGElement", "changeSignal", "newSignal", "newProps", "setAttribute", "removeAttribute", "index", "Component", "shouldComponentUpdate", "state", "hasSignals", "_sources", "__f", "u", "useComputed", "compute", "$compute", "useRef", "current", "useSignalEffect", "cb", "callback", "useEffect"]
}
