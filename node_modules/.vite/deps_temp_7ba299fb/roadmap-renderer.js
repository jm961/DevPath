import {
  __publicField
} from "./chunk-34KZWS7D.js";

// node_modules/.pnpm/roadmap-renderer@1.0.7/node_modules/roadmap-renderer/dist/index.mjs
function w(d) {
  let e = d >> 16 & 255, t = d >> 8 & 255, a = d & 255;
  return `rgb(${e},${t},${a})`;
}
function p(d, e = {}, t) {
  let a = document.createElementNS("http://www.w3.org/2000/svg", d);
  for (let n in e)
    e.hasOwnProperty(n) && a.setAttribute(n, e[n]);
  return t && t.appendChild(a), a;
}
var g = { black: ["#000"], gray: ["#000", "#333", "#666", "#999", "#ccc", "#ddd", "#eee"], white: ["#fff"], red: ["#cf2a27", "#ea9999", "#eo6666", "#cc0000", "#990000", "#660000"], orange: ["#ff9900", "#f9cb9c", "#f6b26b", "#e69138", "#b45f06", "#783f04"], yellow: ["#ffff00", "#ffe599", "#ffd966", "#f1c232", "#bf9000", "#7f6000"], green: ["#009e0f", "#b6d7a8", "#93c47d", "#6aa84f", "#38761d", "#274e13"], cyan: ["#00ffff", "#a2c4c9", "#76a5af", "#45818e", "#134f5c", "#0c343d"], blue: ["#2b78e4", "#9fc5f8", "#6fa8dc", "#597eaa", "#085394", "#073763"], purple: ["#9900ff", "#b4a7d6", "#8e7cc3", "#674ea7", "#351c75", "#20124d"], pink: ["#ff00ff", "#d5a6bd", "#c27ba0", "#a64d79", "#741b47", "#4c1130"] };
var x = class {
  constructor(e, t) {
    __publicField(this, "svgRoot");
    __publicField(this, "fontFamily");
    __publicField(this, "canvasRenderingContext2D");
    this.svgRoot = e, this.fontFamily = t, this.canvasRenderingContext2D = document.createElement("canvas").getContext("2d");
  }
  render(e, t) {
    let a = e.typeID;
    a in this ? this[a](e, t) : console.log(`'${a}' control type not implemented`);
  }
  parseColor(e, t) {
    return e === void 0 ? `rgb(${t})` : w(e);
  }
  parseFontProperties(e) {
    var _a, _b, _c;
    return { style: ((_a = e.properties) == null ? void 0 : _a.italic) ? "italic" : "normal", weight: ((_b = e.properties) == null ? void 0 : _b.bold) ? "bold" : "normal", size: ((_c = e.properties) == null ? void 0 : _c.size) ? e.properties.size + "px" : "13px", family: this.fontFamily };
  }
  measureText(e, t) {
    return this.canvasRenderingContext2D.font = t, this.canvasRenderingContext2D.measureText(e);
  }
  drawRectangle(e, t) {
    var _a, _b, _c;
    p("rect", { x: parseInt(e.x) + 2.7 / 2, y: parseInt(e.y) + 2.7 / 2, width: parseInt(e.w ?? e.measuredW) - 2.7, height: parseInt(e.h ?? e.measuredH) - 2.7, rx: 2, fill: this.parseColor((_a = e.properties) == null ? void 0 : _a.color, "255,255,255"), "fill-opacity": ((_b = e.properties) == null ? void 0 : _b.backgroundAlpha) ?? 1, stroke: this.parseColor((_c = e.properties) == null ? void 0 : _c.borderColor, "0,0,0"), "stroke-width": 2.7 }, t);
  }
  addText(e, t, a, n) {
    let r = e.properties.text ?? "", l = parseInt(e.x), o = parseInt(e.y), i = this.parseFontProperties(e), s = this.measureText(r, `${i.style} ${i.weight} ${i.size} ${i.family}`), c = n === "center" ? l + (e.w ?? e.measuredW) / 2 - s.width / 2 : l, k = o + e.measuredH / 2 + s.actualBoundingBoxAscent / 2, u = p("text", { x: c, y: k, fill: a, "font-style": i.style, "font-weight": i.weight, "font-size": i.size }, t);
    if (!r.includes("{color:")) {
      let m = p("tspan", {}, u);
      m.textContent = r;
      return;
    }
    r.split(/{color:|{color}/).forEach((m) => {
      if (m.includes("}")) {
        let [f, R] = m.split("}");
        if (!f.startsWith("#")) {
          let h = parseInt(f.slice(-1));
          f = isNaN(h) ? g[f][0] : g[f][h];
        }
        let I = p("tspan", { fill: f }, u);
        I.textContent = R;
      } else {
        let f = p("tspan", {}, u);
        f.textContent = m;
      }
    });
  }
  TextArea(e, t) {
    this.drawRectangle(e, t);
  }
  Canvas(e, t) {
    this.drawRectangle(e, t);
  }
  Label(e, t) {
    var _a;
    this.addText(e, t, this.parseColor((_a = e.properties) == null ? void 0 : _a.color, "0,0,0"), "left");
  }
  TextInput(e, t) {
    var _a;
    this.drawRectangle(e, t), this.addText(e, t, this.parseColor((_a = e.properties) == null ? void 0 : _a.textColor, "0,0,0"), "center");
  }
  Arrow(e, t) {
    var _a, _b, _c;
    let a = parseInt(e.x), n = parseInt(e.y), { p0: r, p1: l, p2: o } = e.properties, i;
    ((_a = e.properties) == null ? void 0 : _a.stroke) === "dotted" ? i = "0.8 12" : ((_b = e.properties) == null ? void 0 : _b.stroke) === "dashed" && (i = "28 46");
    let s = { x: (o.x - r.x) * l.x, y: (o.y - r.y) * l.x };
    p("path", { d: `M${a + r.x} ${n + r.y}Q${a + r.x + s.x + s.y * l.y * 3.6} ${n + r.y + s.y + -s.x * l.y * 3.6} ${a + o.x} ${n + o.y}`, fill: "none", stroke: this.parseColor((_c = e.properties) == null ? void 0 : _c.color, "0,0,0"), "stroke-width": 4, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-dasharray": i }, t);
  }
  Icon(e, t) {
    var _a;
    let a = parseInt(e.x), n = parseInt(e.y), r = 10;
    p("circle", { cx: a + r, cy: n + r, r, fill: this.parseColor((_a = e.properties) == null ? void 0 : _a.color, "0,0,0") }, t), e.properties.icon.ID === "check-circle" && p("path", { d: `M${a + 4.5} ${n + r}L${a + 8.5} ${n + r + 4} ${a + 15} ${n + r - 2.5}`, fill: "none", stroke: "#fff", "stroke-width": 3.5, "stroke-linecap": "round", "stroke-linejoin": "round" }, t);
  }
  HRule(e, t) {
    var _a, _b, _c;
    let a = parseInt(e.x), n = parseInt(e.y), r;
    ((_a = e.properties) == null ? void 0 : _a.stroke) === "dotted" ? r = "0.8, 8" : ((_b = e.properties) == null ? void 0 : _b.stroke) === "dashed" && (r = "18, 30"), p("path", { d: `M${a} ${n}L${a + parseInt(e.w ?? e.measuredW)} ${n}`, fill: "none", stroke: this.parseColor((_c = e.properties) == null ? void 0 : _c.color, "0,0,0"), "stroke-width": 2.7, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-dasharray": r }, t);
  }
  __group__(e, t) {
    var _a;
    let a = ((_a = e == null ? void 0 : e.properties) == null ? void 0 : _a.controlName) || "", n = p("g", { ...a ? { class: "clickable-group", "data-group-id": a } : {} }, t);
    e.children.controls.control.sort((r, l) => r.zOrder - l.zOrder).forEach((r) => {
      r.x = parseInt(r.x, 10) + parseInt(e.x, 10), r.y = parseInt(r.y, 10) + parseInt(e.y, 10), this.render(r, n);
    });
  }
};
async function O(d, e = {}) {
  if (e = { padding: 5, fontFamily: "balsamiq", fontURL: "https://fonts.gstatic.com/s/balsamiqsans/v3/P5sEzZiAbNrN8SB3lQQX7Pncwd4XIA.woff2", ...e }, e.fontURL) {
    let s = new FontFace(e.fontFamily, `url(${e.fontURL})`);
    await s.load(), document.fonts.add && document.fonts.add(s);
  }
  let t = d.mockup, a = t.measuredW - t.mockupW - e.padding, n = t.measuredH - t.mockupH - e.padding, r = parseInt(t.mockupW) + e.padding * 2, l = parseInt(t.mockupH) + e.padding * 2, o = p("svg", { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: `${a} ${n} ${r} ${l}`, style: "font-family: balsamiq" }), i = new x(o, e.fontFamily);
  return t.controls.control.sort((s, c) => s.zOrder - c.zOrder).forEach((s) => {
    i.render(s, o);
  }), o;
}
export {
  O as wireframeJSONToSVG
};
//# sourceMappingURL=roadmap-renderer.js.map
